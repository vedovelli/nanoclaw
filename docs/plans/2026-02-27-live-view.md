# Live View de Logs — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Adicionar um servidor HTTP embutido no NanoClaw que serve uma página web com tail ao vivo dos logs via Server-Sent Events.

**Architecture:** Novo módulo `src/log-viewer.ts` iniciado em `src/index.ts`. Rota `GET /` serve HTML inline. Rotas `GET /stream/main` e `GET /stream/error` fazem tail dos arquivos de log via SSE. Usa `fs.watch` para detectar novos dados e manda linha a linha para o cliente.

**Tech Stack:** `node:http`, `node:fs`, SSE, `ansi_up` v5 via CDN (sem dependências novas no servidor).

---

### Context: Padrão de customização do projeto

Este projeto usa markers `/* ved custom */` em arquivos upstream. Qualquer adição em `src/config.ts` e `src/index.ts` DEVE estar dentro desses markers.

**Não** adicione markers em `src/log-viewer.ts` — é um arquivo novo, não upstream.

---

### Task 1: Adicionar variáveis de config

**Files:**
- Modify: `src/config.ts`
- Modify: `.env`
- Modify: `.env.example`

**Step 1: Adicionar ao allowlist do `readEnvFile` em `src/config.ts`**

Localize o bloco `readEnvFile([...])` (linha ~8). Adicione dentro dos markers ved custom existentes, ou crie um novo bloco imediatamente após o último `/* ved custom end */` antes do fechamento do array:

```typescript
/* ved custom */
'LOG_VIEWER_ENABLED',
'LOG_VIEWER_PORT',
/* ved custom end */
```

O array ficará assim (parcialmente):
```typescript
const envConfig = readEnvFile([
  'ASSISTANT_NAME',
  // ... outros ...
  /* ved custom */
  'DEVTEAM_ENABLED',
  // ...
  /* ved custom end */
  /* ved custom */
  'LOG_VIEWER_ENABLED',
  'LOG_VIEWER_PORT',
  /* ved custom end */
]);
```

**Step 2: Exportar as constantes em `src/config.ts`**

Adicione ao final do arquivo, após o último export existente:

```typescript
/* ved custom */
export const LOG_VIEWER_ENABLED =
  (process.env.LOG_VIEWER_ENABLED || envConfig.LOG_VIEWER_ENABLED) === 'true';
export const LOG_VIEWER_PORT = parseInt(
  process.env.LOG_VIEWER_PORT || envConfig.LOG_VIEWER_PORT || '4242',
  10,
);
/* ved custom end */
```

**Step 3: Adicionar ao `.env`**

```
LOG_VIEWER_ENABLED=true
LOG_VIEWER_PORT=4242
```

**Step 4: Adicionar ao `.env.example`**

```
# Log viewer web interface (http://localhost:PORT)
LOG_VIEWER_ENABLED=false
LOG_VIEWER_PORT=4242
```

**Step 5: Typecheck**

```bash
npm run typecheck
```

Expected: zero erros.

**Step 6: Commit**

```bash
git add src/config.ts .env .env.example
git commit -m "feat: add LOG_VIEWER_ENABLED and LOG_VIEWER_PORT config"
```

---

### Task 2: Criar `src/log-viewer.ts`

**Files:**
- Create: `src/log-viewer.ts`

Este é o módulo central. Não é arquivo upstream — sem markers ved custom.

**Step 1: Criar o arquivo com o servidor HTTP e SSE**

```typescript
import fs from 'node:fs';
import http from 'node:http';
import path from 'node:path';
import { IncomingMessage, ServerResponse } from 'node:http';

import { LOG_VIEWER_ENABLED, LOG_VIEWER_PORT, PROJECT_ROOT } from './config.js';
import { logger } from './logger.js';

const MAIN_LOG = path.join(PROJECT_ROOT, 'logs', 'nanoclaw.log');
const ERROR_LOG = path.join(PROJECT_ROOT, 'logs', 'nanoclaw.error.log');
const BACKFILL_LINES = 200;

function readLastLines(filePath: string, n: number): string[] {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const lines = content.split('\n').filter((l) => l.length > 0);
    return lines.slice(Math.max(0, lines.length - n));
  } catch {
    return [];
  }
}

function tailFile(filePath: string, onLine: (line: string) => void): () => void {
  let pos = 0;
  try {
    pos = fs.statSync(filePath).size;
  } catch {
    // file doesn't exist yet — start at 0
  }

  let watcher: fs.FSWatcher | null = null;

  function read() {
    try {
      const stat = fs.statSync(filePath);
      if (stat.size < pos) pos = 0; // rotated or truncated
      if (stat.size === pos) return;
      const buf = Buffer.allocUnsafe(stat.size - pos);
      const fd = fs.openSync(filePath, 'r');
      fs.readSync(fd, buf, 0, stat.size - pos, pos);
      fs.closeSync(fd);
      pos = stat.size;
      for (const line of buf.toString('utf-8').split('\n')) {
        if (line.length > 0) onLine(line);
      }
    } catch {
      // file temporarily unavailable — ignore
    }
  }

  try {
    watcher = fs.watch(filePath, read);
  } catch {
    // file doesn't exist yet — no watcher, client gets backfill only
  }

  return () => {
    if (watcher) {
      try { watcher.close(); } catch {}
    }
  };
}

function handleSSE(
  req: IncomingMessage,
  res: ServerResponse,
  logFile: string,
): void {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    Connection: 'keep-alive',
    'X-Accel-Buffering': 'no',
  });

  // Backfill last N lines immediately
  for (const line of readLastLines(logFile, BACKFILL_LINES)) {
    res.write(`data: ${JSON.stringify(line)}\n\n`);
  }

  // Stream new lines as they arrive
  const stop = tailFile(logFile, (line) => {
    try {
      res.write(`data: ${JSON.stringify(line)}\n\n`);
    } catch {
      stop();
    }
  });

  req.on('close', stop);
}

const HTML = `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>NanoClaw Live Logs</title>
  <script src="https://cdn.jsdelivr.net/npm/ansi_up@5/ansi_up.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #1a1a1a; color: #d4d4d4;
      font-family: 'Menlo', 'Consolas', monospace; font-size: 12.5px;
      height: 100vh; display: flex; flex-direction: column;
    }
    header {
      padding: 6px 16px; background: #252525;
      border-bottom: 1px solid #333;
      display: flex; align-items: center; gap: 12px;
    }
    h1 { font-size: 13px; font-weight: normal; color: #666; flex: 1; }
    .status { font-size: 11px; color: #555; }
    .status.connected { color: #4ec9b0; }
    .panels { display: flex; flex: 1; overflow: hidden; }
    .panel { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .panel + .panel { border-left: 1px solid #2a2a2a; }
    .panel-header {
      padding: 4px 12px; background: #1e1e1e; color: #555;
      font-size: 11px; border-bottom: 1px solid #2a2a2a; flex-shrink: 0;
    }
    .panel-content { flex: 1; overflow-y: scroll; padding: 6px 12px; }
    .line { white-space: pre-wrap; line-height: 1.6; }
  </style>
</head>
<body>
  <header>
    <h1>NanoClaw Live Logs</h1>
    <span class="status" id="status-main">main: connecting…</span>
    <span class="status" id="status-error">error: connecting…</span>
  </header>
  <div class="panels">
    <div class="panel">
      <div class="panel-header">nanoclaw.log</div>
      <div class="panel-content" id="panel-main"></div>
    </div>
    <div class="panel">
      <div class="panel-header">nanoclaw.error.log</div>
      <div class="panel-content" id="panel-error"></div>
    </div>
  </div>
  <script>
    /* global AnsiUp */
    const au = new AnsiUp();
    au.use_classes = false;

    function connect(url, panelId, statusId) {
      const panel = document.getElementById(panelId);
      const statusEl = document.getElementById(statusId);
      let autoScroll = true;

      panel.addEventListener('scroll', () => {
        const atBottom = panel.scrollHeight - panel.scrollTop - panel.clientHeight < 60;
        autoScroll = atBottom;
      });

      const es = new EventSource(url);

      es.onopen = () => {
        statusEl.textContent = panelId.replace('panel-', '') + ': live';
        statusEl.className = 'status connected';
      };

      es.onmessage = (e) => {
        const raw = JSON.parse(e.data);
        const div = document.createElement('div');
        div.className = 'line';
        div.innerHTML = au.ansi_to_html(raw);
        panel.appendChild(div);
        if (autoScroll) panel.scrollTop = panel.scrollHeight;
      };

      es.onerror = () => {
        statusEl.textContent = panelId.replace('panel-', '') + ': reconnecting…';
        statusEl.className = 'status';
      };
    }

    connect('/stream/main', 'panel-main', 'status-main');
    connect('/stream/error', 'panel-error', 'status-error');
  </script>
</body>
</html>`;

function serveHtml(res: ServerResponse): void {
  res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
  res.end(HTML);
}

export function startLogViewer(): void {
  if (!LOG_VIEWER_ENABLED) return;

  const server = http.createServer(
    (req: IncomingMessage, res: ServerResponse) => {
      const url = req.url ?? '/';
      if (url === '/stream/main') return handleSSE(req, res, MAIN_LOG);
      if (url === '/stream/error') return handleSSE(req, res, ERROR_LOG);
      if (url === '/' || url === '/index.html') return serveHtml(res);
      res.writeHead(404);
      res.end('Not found');
    },
  );

  server.listen(LOG_VIEWER_PORT, '127.0.0.1', () => {
    logger.info({ port: LOG_VIEWER_PORT }, 'Log viewer started at http://localhost:' + LOG_VIEWER_PORT);
  });

  server.on('error', (err) => {
    logger.error({ err }, 'Log viewer server error');
  });
}
```

**Step 2: Typecheck**

```bash
npm run typecheck
```

Expected: zero erros. Se `PROJECT_ROOT` não existir em `config.ts`, verifique o nome exato:

```bash
grep -n "PROJECT_ROOT\|project_root\|__dirname\|process.cwd" src/config.ts
```

Se não existir, substitua `PROJECT_ROOT` por `process.cwd()` no import e no topo do arquivo.

**Step 3: Commit**

```bash
git add src/log-viewer.ts
git commit -m "feat: add log-viewer HTTP server with SSE streaming"
```

---

### Task 3: Integrar em `src/index.ts`

**Files:**
- Modify: `src/index.ts`

**Step 1: Adicionar import com marker ved custom**

Localize o bloco de imports no topo de `src/index.ts`. Adicione após o último import existente (antes das declarações `let`):

```typescript
/* ved custom */
import { startLogViewer } from './log-viewer.js';
/* ved custom end */
```

**Step 2: Chamar `startLogViewer()` na startup**

Localize a função `main()` em `src/index.ts`. Após a chamada a `startSchedulerLoop(...)` (linha ~709), adicione:

```typescript
/* ved custom */
startLogViewer();
/* ved custom end */
```

**Step 3: Typecheck**

```bash
npm run typecheck
```

Expected: zero erros.

**Step 4: Commit**

```bash
git add src/index.ts
git commit -m "feat: start log viewer on NanoClaw startup"
```

---

### Task 4: Build e teste manual

**Step 1: Build**

```bash
npm run build
```

Expected: zero erros.

**Step 2: Iniciar em modo dev**

```bash
npm run dev
```

Aguarde a linha:
```
INFO: Log viewer started at http://localhost:4242
```

**Step 3: Abrir o browser**

Acesse `http://localhost:4242`. Verifique:
- [ ] Dois painéis aparecem lado a lado
- [ ] Backfill das últimas ~200 linhas aparece imediatamente
- [ ] Status mostra "live" em verde
- [ ] Novas linhas de log aparecem em tempo real
- [ ] Auto-scroll funciona (pausa ao scrollar para cima, retoma ao voltar ao fim)
- [ ] Cores ANSI estão sendo convertidas corretamente (não aparecem como `\u001b[32m`)

**Step 4: Teste de reconexão**

Reinicie o serviço e confirme que o browser reconecta automaticamente sem refresh manual.

**Step 5: Se `LOG_VIEWER_ENABLED=false` no `.env`**

Verifique que o servidor não sobe (sem log "Log viewer started").

---

### Task 5: Commit final e restart do serviço

**Step 1: Restart do serviço de produção**

```bash
launchctl kickstart -k gui/$(id -u)/com.nanoclaw
```

**Step 2: Verificar log**

```bash
tail -20 logs/nanoclaw.log | grep "log viewer\|Log viewer"
```

Expected: `INFO: Log viewer started at http://localhost:4242`

**Step 3: Confirmar contagem de markers ved custom**

```bash
grep -rn "ved custom" src/ container/ --include="*.ts" --include="Dockerfile" --include="*.sh" | wc -l
```

Compare com a contagem anterior à implementação. Deve ter aumentado (novos markers em config.ts e index.ts).
